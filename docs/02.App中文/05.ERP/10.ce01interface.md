---
nav: zh-CN
title: ERP EJB 接口
date: 2024-02-27 16:42:51
permalink: /pages/aeea3b/
---

`版本: 1.2 | 发布日期: 07/02/2024`

## MassMailHandler

### 目的

用于在[邮件报告设定]发送电子邮件时处理电子邮件。

<br/>

### `handleEmail`函数

```java
	public default void handleEmail(MacEmail email, SqlTable massmail, CawReport report, CawReportDataSet dataSet) {
	}
```

**说明**

用于在[邮件报告设定]发送电子邮件时处理电子邮件。

**参数**

| 名称       | 类型                 | 说明         |
| -------- | ------------------ | ---------- |
| email    | `MacEmail`         | 邮件         |
| massmail | `SqlTable`         | [邮件报告设定]主表 |
| report   | `CawReport`        | 报表         |
| dataSet  | `CawReportDataSet` | 报表数据       |

<br/>

------

### `sendEmail`函数

```java
	public default Set<MacEmail> sendEmail(SqlTable massmail, CawReport report, CawReportDataSet dataSet, Map<Long, String> fileKey, Map<String, String> fileMap) {
		return null;
	}
```

**说明**

它用于通过[邮件报告设定]发送电子邮件时，发送给更多的电子邮件地址。

例如：在 core App 中，可以从客户/供应商/职员/部门/商业中心中获取邮件地址。

例如：在 ac App 中，可以从应收对象/应付对象中获取邮件地址。

**参数**

| 名称       | 类型                    | 说明                       |
| -------- | --------------------- | ------------------------ |
| massmail | `SqlTable`            | [邮件报告设定]主表               |
| report   | `CawReport`           | 报表                       |
| dataSet  | `CawReportDataSet`    | 报表数据                     |
| fileKey  | `Map<Long, String>`   | 预览文件的键值对，键是单据的ID，值是文件名。  |
| fileMap  | `Map<String, String>` | 预览文件路径的键值对，键是文件名，值是文件路径。 |

**返回值**

| 类型              | 说明       |
| --------------- | -------- |
| `Set<MacEmail>` | 额外需发送的邮件 |

<br/>

<br/>

## UpdateFrozenDate

### 目的

在冻结日期要更新前后，开发人员可以进行干预操作。

<br/>

### `beforeUpdateFrozen`函数

```java
	public default String beforeUpdateFrozen(Long beId, Long frozenTypeId, Date frozenDate) {
		return "";
	}
```

**说明**

冻结日期要更新前触发此函数。

**参数**

| 名称           | 类型     | 说明        |
| ------------ | ------ | --------- |
| beId         | `Long` | 企业法人ID    |
| frozenTypeId | `Long` | 交易冻结期类型ID |
| frozenDate   | `Date` | 交易冻结期     |

**返回值**

| 类型       | 说明                 |
| -------- | ------------------ |
| `String` | 运行结果说明的`messCode`。 |

**例子**

```java
	@Override
	public String beforeUpdateFrozen(Long beId, Long frozenTypeId, Date frozenDate) {
		SqlTable data = MacCheckerUtil.excuteQuery("frozentype", " id = " + frozenTypeId);
		if (data != null && data.size() > 0) {
			SqlTable beFile = MacUtil.getBeGlobalSetting(beId);
			if (beFile != null && beFile.size() > 0) {
				if (frozenDate.before((Date) beFile.getValue(1, "stkClosed"))) {
					return "ce01_core.frozenPeriodSTKError";
				}
			}
		}
		return "";
	}
```

<br/>

------

### `afterUpdateFrozen`函数

```java
	public default void afterUpdateFrozen(Long beId, Long frozenTypeId, Date frozenDate) {

	}
```

**说明**

冻结日期要更新后触发此函数。

**参数**

| Name         | Type   | Description |
| ------------ | ------ | ----------- |
| beId         | `Long` | 企业法人ID      |
| frozenTypeId | `Long` | 交易冻结期类型ID   |
| frozenDate   | `Date` | 交易冻结期       |

<br/>

<br/>

## ErpServerInitialized

### 目的

在同步数据库之后和JBoss完全启动之前，将触发此接口。

它通常用于初始化缓存或初始化数据。

<br/>

### `contextInitialized`函数

```java
	public default void contextInitialized() {

	}
```

**说明**

在同步数据库之后和JBoss完全启动之前，将触发此函数。

<br/>

------

### `afterInitialized`函数

```java
	public default void afterInitialized() {

	}
```

**说明**

在 `contextInitialized()`之后触发。

<br/>

<br/>

## GenerateRecord

### 目的

用于创建模块单据，生成另一个模块单据时，与M18交互。 （示例：送货单生成销售发票记录）

<br/>

### `beforeSaveRecord`函数

```java
	public default boolean beforeSaveRecord(SqlEntity fromEntity, SqlEntity entity, String jsonParam) {
		return true;
	}
```

**说明**

当目标单据（例如销售发票）准备好保存时触发此函数。 如果开发人员需要中止保存过程，则返回false。

**参数**

| 名称         | 类型          | 说明                       |
| ---------- | ----------- | ------------------------ |
| fromEntity | `SqlEntity` | 来源单据实体数据。例如: [送货单]实体数据。  |
| entity     | `SqlEntity` | 目标单据实体数据。例如: [销售发票]实体数据。 |
| jsonParam  | `String`    | 额外的参数.                   |

**返回值**

| 类型        | 说明                   |
| --------- | -------------------- |
| `boolean` | 如果是 `false`，则中止保存操作。 |

<br/>

<br/>

## SpecBsRuleItem

### 目的

用于与M18交互，在系统中增加额外的业务规则。

<br/>

### `getSpecBsRuleItem`函数

```java
	public default List<BsRuleItem> getSpecBsRuleItem(Long beId, String moduleName) {
		return null;
	}
```

**说明**

当M18读取业务规则项时触发。 开发人员可以在Java中定义其他额外的业务规则并返回系统。

**参数**

| 名称         | 类型       | 说明        |
| ---------- | -------- | --------- |
| beId       | `Long`   | 企业法人ID    |
| moduleName | `String` | 触发业务规则的模块 |

**返回值**

| 类型                 | 说明       |
| ------------------ | -------- |
| `List<BsRuleItem>` | 额外业务规则列表 |

**例子**

```java
public class TrdgSpecBsRuleItem implements SpecBsRuleItem {

	@Override
	public List<BsRuleItem> getSpecBsRuleItem(Long beId, String moduleName) {
		if (!MacUtil.matchAppModule(moduleName, TradeStaticVar.appName)
				&& !TradeUtil.isTradingUdfEditor(moduleName)) {
			return null;
		}
		List<BsRuleItem> specItems = new ArrayList<BsRuleItem>();
		BsRule rules = (BsRule) CawCache.getObject(ErpStaticVar.bsRule, "xxxx");
		if (rules != null) {
			if (TradeUtil.isAllowNs(beId) && TradeUtil.checkInventoryModule(beId, moduleName)) {
				BsRuleItem allowNsItem = rules.getChkList().get("allowNs");
				specItems.add(allowNsItem);
			}
		}
		return specItems;
	}
}
```

<br/>

<br/>

## ASaveChkHandler

### 目的

用于在保存单据时与M18交互。 通常用于检查单据下款表的外键约束。

例如，若[送货单]下款的来源[销售订单]中的货币ID不等于[送货单]中的货币ID，则销售订单无法保存。

<br/>

### `getASaveChkSql`函数

```java
	public default String getASaveChkSql(ASaveChkItem item, String moduleName, SqlTable mainData, String chkValue, String joinkeycol) {
		return null;
	}
```

**说明**

定义用于检查以上示例是否有效的SQL：

若[送货单]下款的来源[销售订单]中的货币ID不等于[送货单]中的货币ID，则销售订单无法保存。

如果通过运行SQL返回的数据集非空，则无法保存单据并弹出错误。

**参数**

| 名称         | 类型             | 说明      |
| ---------- | -------------- | ------- |
| item       | `ASaveChkItem` | 检查的项目   |
| moduleName | `String`       | 模块名称    |
| mainData   | `SqlTable`     | 保存单据的主表 |
| chkValue   | `String`       | 检查栏位的值  |
| joinkeycol | `String`       | 链接主键的条件 |

**返回值**

| 类型       | 说明     |
| -------- | ------ |
| `String` | SQL 语句 |

<br/>

<br/>

## GeneratedEJBLot

### 目的

用于在在EJB中生成行次时与M18交互。

<br/>

### `originAccept`函数

```java
	public boolean originAccept(String module);
```

**说明**

当行次将要生成时触发此函数。 用于确定当前模块是否应使用此接口生成批号。

**参数**

| 名称     | 类型       | 说明   |
| ------ | -------- | ---- |
| module | `String` | 模块名称 |

**返回值**

| 类型        | 说明                                       |
| --------- | ---------------------------------------- |
| `boolean` | 若为`true` 则可以继续调用此接口中的`generate()`生成行次，若为 `fales`，则按照系统默认规则生成行次。 |

<br/>

------

### `generate`函数

```java
	public String generate(final String module, final Long beId, final int rowIndex, final SqlTable footer, final String[] emptyField, final String lotField, final String proField);
```

**说明**

当`originAccept()` 返回`true`时，会触发此函数，此函数用来生成行次。

**参数**

| 名称         | 类型         | 说明             |
| ---------- | ---------- | -------------- |
| module     | `String`   | 模块名称           |
| beId       | `Long`     | 企业法人ID         |
| rowIndex   | `int`      | 当前下款表行次        |
| footer     | `SqlTable` | 当前下款表          |
| emptyField | `String[]` | 判断当前行是否为空的关键栏位 |
| lotField   | `String`   | 行次栏位           |
| proField   | `String`   | 产品栏位           |

**返回值**

| 类型       | 说明    |
| -------- | ----- |
| `String` | 生成的行次 |

<br/>

<br/>

## GeneratedJSFLot

### 目的

当行次将要在JSF中生成时使用此接口。 函数与 `GeneratedEJBLot`相同，请参阅 [GeneratedEJBLot](#GeneratedEJBLot) 以获取更多详细信息。

<br/>

<br/>

## LoadTradeFooter

### 目的

从来源单据加载下款数据时触发，用于在下款表中加载单价和说明字段。

<br/>

### `getMultiProPriceDesc`函数

```java
	public default SqlTable getMultiProPriceDesc(String moduleName, Long beId, Long refId, Long virDeptId, String date, String upOrigin, String descOrigin, SqlTable footer, String[] proField, String jsonParam, SqlTable result) {
		return null;
	}
```

**说明**

系统从来源单据读取下款数据后触发，开发人员可以使用此功能修改或覆盖结果集。

**参数**

| 名称         | 类型         | 说明       |
| ---------- | ---------- | -------- |
| module     | `String`   | 模块名称     |
| beId       | `Long`     | 企业法人ID   |
| refId      | `Long`     | 客户/供应商ID |
| virDeptId  | `Long`     | 商业中心ID   |
| date       | `String`   | 单据日期     |
| upOrigin   | `String`   | 产品价格来源   |
| descOrigin | `String`   | 产品说明来源   |
| footer     | `SqlTable` | 下款表      |
| proField   | `String[]` | 确定唯一性的字段 |
| jsonParam  | `String`   | 额外的参数    |
| result     | `SqlTable` | 结果集      |

**返回值**

| 类型         | 说明       |
| ---------- | -------- |
| `SqlTable` | 修改后的结果集。 |

<br/>

------

### `assign_footer_updesc`函数

```java
	public default void assign_footer_updesc(SqlTable footer, int footerIndex, SqlTable tarTable, int rec) {

	}
```

**说明**

在系统加载<精简说明>和<详细说明>或者<单位价格>后，触发此函数。开发人员可以修改对应栏位的值。

**参数**

| 名称          | 类型         | 说明      |
| ----------- | ---------- | ------- |
| footer      | `SqlTable` | 下款表     |
| footerIndex | `int`      | 下款表行次   |
| tarTable    | `SqlTable` | 来源数据表   |
| rec         | `int`      | 来源数据表行次 |

<br/>

<br/>

## AssignLotnoHelper

### 目的

用于开发人员与M18交互，修改已读取的系统默认的批号表信息。

<br/>

### `isAccept`函数

```java
	public boolean isAccept();
```

**说明**

用于决定这个接口的其他函数是否继续运行。

**返回值**

| Type      | Description                              |
| --------- | ---------------------------------------- |
| `boolean` | 若为`true` ，则继续运行这个接口的其他函数。若为 `false`， 则中止运行这个接口的其他函数 。 |

<br/>

------

### `getAssignLotno`函数

```java
	public SqlTable getAssignLotno(long beId, String module, SqlTable stock);
```

**说明**

当M18读取了产品的批号库存信息后，开发人员可以在这个函数中修改批号库存表的信息。

**参数**

| 名称     | 类型         | 说明     |
| ------ | ---------- | ------ |
| beId   | `long`     | 企业法人ID |
| module | `String`   | 模块名称   |
| stock  | `SqlTable` | 库存批号表  |

**返回值**

| 类型         | 说明        |
| ---------- | --------- |
| `SqlTable` | 修改后的库存批号表 |

<br/>

------

### `sortStock`函数

```java
	public void sortStock(String module, SqlTable stock, List<String> sortFieldList, List<Boolean> sortTypeList);
```

**说明**

在`getAssignLotno()`之后触发，用来为库存批号表重新排序。

**参数**

| 名称            | 类型              | 说明                                       |
| ------------- | --------------- | ---------------------------------------- |
| module        | `String`        | 模块名称                                     |
| stock         | `SqlTable`      | 库存批号表                                    |
| sortFieldList | `List<String>`  | 排序字段列表                                   |
| sortTypeList  | `List<Boolean>` | 排序字段列表对应的排序方式。若为 `true`，则是升序，若为 `false` ，则是降序。 |

<br/>

------

### `isStockFit`函数

```java
	public boolean isStockFit(String module, SqlTable stock, int stockIndex, SqlTable footer, int footerIndex);
```

**说明**

判断当前库存批号表的行，是否符合分配的条件。

**参数**

| 名称          | 类型         | 说明        |
| ----------- | ---------- | --------- |
| module      | `String`   | 模块名称      |
| stock       | `SqlTable` | 库存批号表     |
| stockIndex  | `int`      | 库存批号表行次   |
| footer      | `SqlTable` | 被分配批号的下款表 |
| footerIndex | `int`      | 下款表行次     |

**返回值**

| 类型        | 说明                         |
| --------- | -------------------------- |
| `boolean` | 若为 `false`，则库存批号表当前行不能被分配。 |

<br/>

<br/>

## IMacCalcHandler

### 目的

该接口用于M18移动应用程序与M18交互。

<br/>

### `getOrder`函数

```java
	public int getOrder();
```

**说明**

定义接口的顺序，数字越小，接口调用越早。

**返回值**

| 类型    | 说明           |
| ----- | ------------ |
| `int` | 返回代表调用顺序的数字。 |

<br/>

------

### `efe_mainfooter_up`函数

```java
	public void efe_mainfooter_up(long beId, String tranType, SqlTable footer, int rowIndex);
```

**说明**

<单位价格>被赋值时触发。

**参数**

| 名称       | 类型         | 说明     |
| -------- | ---------- | ------ |
| beId     | `long`     | 企业法人ID |
| tranType | `String`   | 模块名称   |
| footer   | `SqlTable` | 下款表    |
| rowIndex | `int`      | 下款表行次  |

<br/>

------

### `calc_invamt`函数

```java
	public default void calc_invamt(long beId, String tranType, SqlTable mainData, SqlTable mainFooter, SqlTable mainDisc) {
	}
```

**说明**

用于在保存单据之前计算上款中的<总金额/总费用/总折扣/折实金额>。

**参数**

| 名称         | 类型         | 说明       |
| ---------- | ---------- | -------- |
| beId       | `long`     | 企业法人ID   |
| tranType   | `String`   | 模块名称     |
| mainData   | `SqlTable` | 主表       |
| mainFooter | `SqlTable` | 下款表      |
| mainDisc   | `SqlTable` | 附加折扣/收费表 |

<br/>

------

### `getInChargeQtyField`函数

```java
	public default String getInChargeQtyField() {
		return "qty";
	};
```

**说明**

用户获取下款表计算金额时所使用的数量栏位名。

**返回值**

| 类型       | 说明               |
| -------- | ---------------- |
| `String` | 返回下款表计算金额时的数量栏位名 |

<br/>

------

### `getFooterUpField`函数

```java
	public default String getFooterUpField() {
		return "up";
	}
```

**说明**

用户获取下款表计算金额时所使用的单价栏位名。

**返回值**

| 类型       | 说明               |
| -------- | ---------------- |
| `String` | 返回下款表计算金额时的单价栏位名 |

<br/>

------

### `getFooterUcField`函数

```java
	public default String getFooterUcField() {
		return "uc";
	}
```

**说明**

用户获取下款表计算金额时所使用的成本栏位名。

**返回值**

| 类型       | 说明               |
| -------- | ---------------- |
| `String` | 返回下款表计算金额时的成本栏位名 |

<br/>

<br/>

## UpdateProCost

### 目的

开发人员与M18交互，用于计算库存成本。

<br/>

### 详细说明

```java
public interface UpdateProCost {

	/**
	 * For Product LLC
	 * this function can be replaced by using procedure named get_pro_llc_*
	 */
	public default SqlTable getMatList(Long beId, SqlTable varList) {
		return null;
	}

	/**
	 * For Data Updating(Stock In UC)
	 */
	public default void beforeLoadData(Long beId, SqlTable varList, SqlTable codeList) {

	}

	/**
	 * can append special field used in the getCalcUc
	 * or
	 * update data
	 */
	public default void afterLoadData(Long beId, SqlTable varList, SqlTable codeList, SqlTable stockIn, SqlTable stockOut, SqlTable stock_open) {

	}

	/**
	 * 1: return false(CalcUcStatus.skipOther) means skip the other instance of UpdateProCost
	 * 2: for special value please set it to CalcUcStatus.uc(and set CalcUcStatus.setUc = true)
	 */
	public default CalcUcStatus getCalcUc(String stk_mth, boolean isStockIn, int rowIndex, double calcUc, SqlTable tempVarList, SqlTable tempStockIn, SqlTable tempStockOut) {
		return null;
	}

	public default boolean calcFIFOUc(Long beId, SqlTable inVARLIST, Long proId, Date tranDate, int outIndex, SqlTable stockIn, SqlTable stockOut, SqlTable stock_open, SqlTable outAss, SqlTable retAss, SqlTable retUesd) {
		return false;
	}

	/**
	 * For Product Cost Updating(PC)
	 */
	public default void afterUpdateUc(Long beId, SqlTable varList, SqlTable codeList) {

	}

	/**
	 * For Data Updating After Close Stock
	 */
	public default void afterCloseStock(Long beId, SqlTable varList) {

	}

	/**
	 * For Data Updating After Reverse Stock
	 */
	public default void afterReverseStock(Long beId, SqlTable varList) {

	}
}
```

<br/>

<br/>

## LoadBomDataSourceHelper

### 目的

用于给开发人员修改读取的即时成本里的BOM资料信息。

<br/>

### `updateBomDataSourceData`函数

```java
	public List<SqlTable> updateBomDataSourceData(SqlEntity entity, int bomRec, int footerIndex, List<SqlTable> bomInfo, String bomDataSource);
```

**说明**

读取即时成本资料时触发。

**参数**

| 名称            | 类型               | 说明                                       |
| ------------- | ---------------- | ---------------------------------------- |
| entity        | `SqlEntity`      | 当前模块的数据实体                                |
| bomRec        | `int`            | BOM的行次                                   |
| footerIndex   | `int`            | 下款表的行次                                   |
| bomInfo       | `List<SqlTable>` | 读取BOM信息的列表，使用`bomInfo.get(0)` 获取BOM的主查询信息。 |
| bomDataSource | `String`         | 数据来源类型                                   |

**返回值**

| 类型        | 说明                |
| --------- | ----------------- |
| `boolean` | 返回修改后的 `bomInfo`. |

<br/>

<br/>

## ModuleSettingHelper

### 目的

用于扩展判定模块是否为库存模块。

<br/>

### `checkInventoryModule`函数

```java
	public boolean checkInventoryModule(long beId, String moduleName);
```

**说明**

判断当前模块是否为库存模块。

**参数**

| 名称         | 类型       | 说明     |
| ---------- | -------- | ------ |
| beId       | `long`   | 企业法人ID |
| moduleName | `String` | 模块名称   |

**返回值**

| 类型        | 说明                   |
| --------- | -------------------- |
| `boolean` | 若为`true`，则当前模块为库存模块。 |

<br/>

------

### `getStkModule`函数

```java
	public SqlTable getStkModule();
```

**说明**

用户读取库存模块，用来生成[业务流程]的缓存数据。

**返回值**

| 类型         | 说明                                       |
| ---------- | ---------------------------------------- |
| `SqlTable` | 一个只有一列(`module`)的 `SqlTable` 表。提供额外的库存模块。 |

<br/>

<br/>

## GenerateVoucher

### 目的

用于开发者与M18，在生成交易单据的凭证时的交互。

<br/>

### `getUDFOrder`函数

```java
	public default int getUDFOrder(long beId, String moduleName, SqlEntity entity, boolean isStock) {
		return -1;
	}
```

**说明**

用于决定 `GenerateUDFVoucher()`函数是否该调用。返回的数值必须大于 `-1`。

**参数**

| 名称         | 类型          | 说明             |
| ---------- | ----------- | -------------- |
| beId       | `long`      | 企业法人ID         |
| moduleName | `String`    | 模块名称           |
| entity     | `SqlEntity` | 当前单据的实体数据      |
| isStock    | `boolean`   | 用于标志该单据是否为库存单据 |

**返回值**

| 类型    | 说明                                       |
| ----- | ---------------------------------------- |
| `int` | `GenerateUDFVoucher()` 需要被调用，返回值必须大于 `-1`。 |

<br/>

------

### `GenerateUDFVoucher`函数

```java
	public default Object GenerateUDFVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock) {
		return null;
	}
```

**说明**

重写系统默认凭证生成规则， 将新SQL提供给系统并生成凭证。

**参数**

| 名称         | 类型          | 说明          |
| ---------- | ----------- | ----------- |
| beId       | `long`      | 企业法人ID      |
| moduleName | `String`    | 模块名称        |
| entity     | `SqlEntity` | 单据实体数据      |
| isStock    | `boolean`   | 标志单据是否为库存单据 |

**返回值**

| 类型       | 说明                                       |
| -------- | ---------------------------------------- |
| `Object` | 若返回 `null` ，则当前函数无任何影响，进程继续运行。若返回 `CheckMsg` ，则中止当前运行进程，单据会保存失败。若返回 `List<String>` ，则包含所有生成凭证的SQL语句。 |

<br/>

------

### `beforeGenerateVoucher`函数

```java
	public String beforeGenerateVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock);
```

**说明**

`GenerateUDFVouche()`返回`null`时触发，开发人员可以在生成默认SQL语句之前提供其他的SQL语句。

**参数**

| 名称         | 类型          | 说明            |
| ---------- | ----------- | ------------- |
| beId       | `long`      | 企业法人ID        |
| moduleName | `String`    | 模块名称          |
| entity     | `SqlEntity` | 单据实体数据        |
| isStock    | `boolean`   | 标志单据是否为库存相关单据 |

**返回值**

| 类型       | 说明                         |
| -------- | -------------------------- |
| `String` | 返回SQL语句必须在执行系统生成的SQL语句前执行。 |

<br/>

------

### `beforeGenT`函数

```java
	public String beforeGenT(long beId, String moduleName, SqlEntity entity, boolean isStock);
```

**说明**

当 `GenerateUDFVoucher()` 返回`null`并且开发人员在生成默认SQL语句之前提供其他SQL语句时触发。

**参数**

| 名称         | 类型          | 说明            |
| ---------- | ----------- | ------------- |
| beId       | `long`      | 企业法人ID        |
| moduleName | `String`    | 模块名称          |
| entity     | `SqlEntity` | 单据实体数据        |
| isStock    | `boolean`   | 标志单据是否为库存相关单据 |

**返回值**

| 类型       | 说明                           |
| -------- | ---------------------------- |
| `String` | 返回的SQL语句需要在系统生成的SQL语句执行之前执行。 |

<br/>

------

### `afterGenerateVoucher`函数

```java
	public String afterGenerateVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock, Long voucherId, boolean genModel);
```

**说明**

`GenerateUDFVoucher()`返回`null`并且开发人员在生成凭证的所有默认SQL语句执行后有提供其他SQL语句时触发。

**参数**

| 名称         | 类型          | 说明            |
| ---------- | ----------- | ------------- |
| beId       | `long`      | 企业法人ID        |
| moduleName | `String`    | 模块名称          |
| entity     | `SqlEntity` | 单据实体数据        |
| isStock    | `boolean`   | 标志单据是否为库存相关单据 |
| voucherId  | `Long`      | 记账凭证ID        |
| genModel   | `boolean`   | 标志凭证是否是即时生成的。 |

**返回值**

| 类型       | 说明                          |
| -------- | --------------------------- |
| `String` | 返回的SQL语句需要在系统生成的SQL语句执行后执行。 |

<br/>

------

### `afterGenerateInstanceVoucher`函数

```java
	public String afterGenerateInstanceVoucher(long beId, String moduleName, SqlEntity entity, boolean isStock);
```

**说明**

`afterGenerateVoucher()` 之后触发，并在保存交易后生成凭证（即时凭证）。

**参数**

| 名称         | 类型          | 说明            |
| ---------- | ----------- | ------------- |
| beId       | `long`      | 企业法人ID        |
| moduleName | `String`    | 模块名称          |
| entity     | `SqlEntity` | 单据实体数据        |
| isStock    | `boolean`   | 标志单据是否为库存相关单据 |

**返回值**

| 类型       | 说明                          |
| -------- | --------------------------- |
| `String` | 返回的SQL语句需要在系统生成的SQL语句执行后执行。 |

<br/>

------

### `afterGenerateModuleVoucher`函数

```java
	public String afterGenerateModuleVoucher(long beId, String moduleName, List<Long> ids, boolean isStock);
```

**说明**

在模块是批量生成凭证的条件下，并所有系统默认的SQL语句生成时触发。

**参数**

| 名称         | 类型           | 数名            |
| ---------- | ------------ | ------------- |
| beId       | `long`       | 企业法人ID        |
| moduleName | `String`     | 模块名称          |
| ids        | `List<Long>` | 单据的ID列表       |
| isStock    | `boolean`    | 标志单据是否为库存相关单据 |

**返回值**

| 类型       | 说明                         |
| -------- | -------------------------- |
| `String` | 返回的SQL语句需要在系统生成的SQL语句执行后执行 |

<br/>

------

### `afterGenerateTranVoucher`函数

```java
	public String afterGenerateTranVoucher(long beId, String moduleName, long ids, boolean isStock);
```

**说明**

在模块是批量生成凭证的条件下，并所有系统默认的SQL语句生成时触发。

**参数**

| 名称         | 类型        | 说明            |
| ---------- | --------- | ------------- |
| beId       | `long`    | 企业法人ID        |
| moduleName | `String`  | 模块名称          |
| ids        | `long`    | 单据的ID列表       |
| isStock    | `boolean` | 标志单据是否为库存相关单据 |

**返回值**

| 类型       | 说明                         |
| -------- | -------------------------- |
| `String` | 返回的SQL语句需要在系统生成的SQL语句执行后执行 |

<br/>

------

### `afterBatchRevertVoucher`函数

```java
	public String afterBatchRevertVoucher(long beId, long jlId);
```

**说明**

在凭证要还原并且所有系统默认的SQL语句生成的时候触发。

**参数**

| 名称   | 类型     | 说明          |
| ---- | ------ | ----------- |
| beId | `long` | 企业法人ID      |
| jlId | `long` | 要还原的凭证的ID列表 |

**返回值**

| 类型       | 说明                         |
| -------- | -------------------------- |
| `String` | 返回的SQL语句需要在系统生成的SQL语句执行后执行 |

<br/>

<br/>

## PrqAllocate

### 目的

在处理生成MRP单据时与M18进行交互。

<br/>

### `supply_demand`函数

```java
	void supply_demand(long beId, SqlTable etdList, SqlTable etaList, SqlTable stkList, SqlTable etd_supply_List);
```

**说明**

为MRP生成单据中的特殊情况分配需求和供应数量。

**参数**

| 名称              | 类型         | 说明             |
| --------------- | ---------- | -------------- |
| beId            | `long`     | 企业法人ID         |
| etdList         | `SqlTable` | 步骤2中需求列表       |
| etaList         | `SqlTable` | 步骤2中供应列表       |
| stkList         | `SqlTable` | 库存列表           |
| etd_supply_List | `SqlTable` | 按[可用量配置]的分配结果。 |

<br/>

<br/>

## LoadLockTranHelper

### 目的

[锁定/解锁物料]模块与M18的交互。

<br/>

### `addLoadLockTranCond`函数

```java
	public void addLoadLockTranCond(long beId, String loadType, String module, List<FormatCond> conds);
```

**说明**

读取相应的锁定/无锁定的物料时触发。 开发人员可以修改条件并影响搜索结果。

**参数**

| 名称       | 类型                 | 说明                              |
| -------- | ------------------ | ------------------------------- |
| beId     | `long`             | 企业法人ID                          |
| loadType | `String`           | 标识读取物料的类型，有`lock`, `release`两种。 |
| module   | `String`           | 读取物料的模块                         |
| conds    | `List<FormatCond>` | 用户自定义的条件                        |



## TradingSettingHelper

### 目的

用于扩展[贸易参数设定]设置模块。

<br/>

### `getLastTranTableName`函数

```java
	public default String getLastTranTableName(String origin) {
		return "";
	}
```

**说明**

获取“上一次交易记录”来源的类型在缓存中的表名称。

**参数**

| 名称     | 类型       | 说明             |
| ------ | -------- | -------------- |
| origin | `String` | “上一次交易记录”来源的类型 |

**返回值**

| 类型       | 说明                       |
| -------- | ------------------------ |
| `String` | 返回“上一次交易记录”来源的类型在缓存中的表名称 |

------

### `addTradingSettingData`函数

```java
	public default void addTradingSettingData(Map<String, SqlTable> cacheMap) {
	}
```

**说明**

为`TradeStaticVar.tradingSetting`缓存增加额外的缓存数据。

**参数**

| 名称       | 类型                      | 说明                                  |
| -------- | ----------------------- | ----------------------------------- |
| cacheMap | `Map<String, SqlTable>` | `TradeStaticVar.tradingSetting`缓存数据 |



## EcnHelper

### 目的

用于扩展[工程变更单]模块。

<br/>

### `ecnChangeProcessExtraData`函数

```java
	public default void ecnChangeProcessExtraData(SqlEntity ecnpEntity, int ecnptRec, SqlEntity bomEntity, int bomptRec) {
	};
```

**说明**

用于[工程变更单(工艺)]模块，对扩展增加的数据，替换到BOM变更单。

**参数**

| 名称         | 类型          | 说明               |
| ---------- | ----------- | ---------------- |
| ecnpEntity | `SqlEntity` | [工程变更单(工艺)]的实体数据 |
| ecnptRec   | `int`       | [工程变更单(工艺)]的行次   |
| bomEntity  | `SqlEntity` | [BOM]的实体数据       |
| bomptRec   | `int`       | [BOM]工艺下款被变更的行次  |



------

### `ecnChangeMatExtraData`函数

```java
	public default void ecnChangeMatExtraData(SqlEntity ecnmEntity, int ecnmtRec, SqlEntity bomEntity, int bomtRec) {
	};
```

**说明**

用于[工程变更单(物料)]模块，对扩展增加的数据，替换到BOM变更单。

**参数**

| 名称         | 类型          | 说明               |
| ---------- | ----------- | ---------------- |
| ecnmEntity | `SqlEntity` | [工程变更单(物料)]的实体数据 |
| ecnmtRec   | `int`       | [工程变更单(物料)]的行次   |
| bomEntity  | `SqlEntity` | [BOM]的实体数据       |
| bomtRec    | `int`       | [BOM]物料下款被变更的行次  |



## DepositDataHelper

### 目的

用于扩展 应收订金单据 和 收取/清缴订金。

<br/>

### `appendArDepositReceipt`函数

```java
public default void appendArDepositReceipt(SqlTable retTable, long beId, long uId, String 			AIType, long AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean 	 loadGroupCo, String arapAlloType) {
}
```

**说明**

用于读取扩展的 订金收款单据/订金使用单据 的数据，例如[零售发票]里收取的订金。

**参数**

| 名称           | 类型         | 说明                            |
| ------------ | ---------- | ----------------------------- |
| retTable     | `SqlTable` | 订金收款的数据                       |
| beId         | `long`     | 企业法人ID                        |
| uId          | `long`     | 当前登录的用户ID                     |
| AIType       | `String`   | 应收对象类别                        |
| AIId         | `long`     | 应收对象ID                        |
| sourceId     | `long`     | 读取数据的单据ID                     |
| tDate        | `String`   | 读取数据的截至日期                     |
| orderList    | `String`   | 读取数据的单据筛选条件（若为空，则代表读取所有单据的数据） |
| moduleFrom   | `String`   | 读取数据的单据类型                     |
| loadGroupCo  | `boolean`  | 是否读取集团数据                      |
| arapAlloType | `String`   | 应收/应付核销读取订金的类别                |



### **例子**

当读取订金收款单据时，需要包括[零售发票]收取的订金，如下扩展：

```java
@Override
public void appendArDepositReceipt(SqlTable retTable, long beId, long uId, String AIType, long   	AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean loadGroupCo, 	String arapAlloType) {
		String sql = "CALL l_poscoreac_recregdeposet (" + beId + ", " + uId + ", '" + AIType + 			"', " + AIId + ", " + sourceId + ", '" + tDate + "','" + orderList + "','" + moduleFrom 		+ "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### `appendApDepositReceipt`函数

```java
public default void appendApDepositReceipt(SqlTable retTable, long beId, long uId, String 			AIType, long AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean 	 loadGroupCo, String arapAlloType) {
}
```

**说明**

用于读取扩展的 订金付款单据/订金使用单据 的数据，例如[委外加工发票]里使用的订金。

**参数**

| 名称           | 类型         | 说明                            |
| ------------ | ---------- | ----------------------------- |
| retTable     | `SqlTable` | 订金付款的数据                       |
| beId         | `long`     | 企业法人ID                        |
| uId          | `long`     | 当前登录的用户ID                     |
| AIType       | `String`   | 应付对象类别                        |
| AIId         | `long`     | 应付对象ID                        |
| sourceId     | `long`     | 读取数据的单据ID                     |
| tDate        | `String`   | 读取数据的截至日期                     |
| orderList    | `String`   | 读取数据的单据筛选条件（若为空，则代表读取所有单据的数据） |
| moduleFrom   | `String`   | 读取数据的单据类型                     |
| loadGroupCo  | `boolean`  | 是否读取集团数据                      |
| arapAlloType | `String`   | 应收/应付核销读取订金的类别                |



### **例子**

当读取订金付款单据时，需要扣减[委外加工发票]使用的订金，如下扩展：

```java
@Override
public void appendApDepositReceipt(SqlTable retTable, long beId, long uId, String AIType, long 		AIId, long sourceId, String tDate, String orderList, String moduleFrom, boolean loadGroupCo, 	String arapAlloType) {
		String sql = "CALL l_pdcoreac_payregdeposet (" + beId + ", " + uId + ", '" + AIType + 			"', " + AIId + ", " + sourceId + ", '" + tDate + "','" + orderList + "','" + moduleFrom 		+ "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			Map<String, Double> depMap = new HashMap<>();
			Map<String, Double> depDomMap = new HashMap<>();

			int deci = MacUtil.getAmtDecimal(beId);
			for (int rec : myTable) {
				String sTranType = myTable.getValueStr(rec, "sTranType");
				long sTranId = myTable.getLong(rec, "sTranId");
				String refType = myTable.getValueStr(rec, "refType");
				long sorId = myTable.getLong(rec, "sorId");
				String lot = myTable.getValueStr(rec, "lot");

				String key = sTranType + StringLib.separate + sTranId + StringLib.separate + 					refType + StringLib.separate + sorId + StringLib.separate + lot;

				double depoAmt = myTable.getDouble(rec, "depoAmt");
				double domDepoAmt = myTable.getDouble(rec, "domDepoAmt");

				if (depMap.containsKey(key)) {
					depoAmt = MathLib.round(depoAmt + depMap.get(key), deci);
				}

				if (depDomMap.containsKey(key)) {
					domDepoAmt = MathLib.round(domDepoAmt + depDomMap.get(key), deci);
				}

				depMap.put(key, depoAmt);
				depDomMap.put(key, domDepoAmt);
			}

			List<Integer> recList = ListLib.newList();

			for (int rec : retTable) {
				String sTranType = retTable.getValueStr(rec, "sTranType");
				long sTranId = retTable.getLong(rec, "sTranId");
				String refType = retTable.getValueStr(rec, "refType");
				long sorId = retTable.getLong(rec, "sorId");
				String lot = retTable.getValueStr(rec, "lot");

				double bal = retTable.getDouble(rec, "bal");
				double balAmt = retTable.getDouble(rec, "balAmt");
				double balDomAmt = retTable.getDouble(rec, "balDomAmt");

				String key = sTranType + StringLib.separate + sTranId + StringLib.separate + 					refType + StringLib.separate + sorId + StringLib.separate + lot;

				if (depMap.containsKey(key)) {
					bal = MathLib.round(bal + depMap.get(key), deci);
					balAmt = MathLib.round(balAmt - depMap.get(key), deci);
				}

				if (depDomMap.containsKey(key)) {
					balDomAmt = MathLib.round(balDomAmt - depDomMap.get(key), deci);
				}

				retTable.setValue(rec, "bal", bal);
				retTable.setValue(rec, "balAmt", balAmt);
				retTable.setValue(rec, "balDomAmt", balDomAmt);

				if (balAmt <= 0) {
					recList.add(rec);
				}
			}

			if (recList.size() > 0) {
				retTable.deleteRows(recList);
			}
		}
}
```



------



### `appendArOsDeposit`函数

```java
public default void appendArOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 	tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
}
```

**说明**

用于读取扩展的 应收订金单据 的数据，例如[委外代销订单]里的订金。

**参数**

| 名称          | 类型         | 说明                            |
| ----------- | ---------- | ----------------------------- |
| retTable    | `SqlTable` | 订金数据                          |
| beId        | `long`     | 企业法人ID                        |
| AIId        | `long`     | 应收对象ID                        |
| uId         | `long`     | 当前登录的用户ID                     |
| tranType    | `String`   | 读取数据的单据类型                     |
| tranId      | `long`     | 读取数据的单据ID                     |
| tDate       | `String`   | 读取数据的截至日期                     |
| orderList   | `String`   | 读取数据的单据筛选条件（若为空，则代表读取所有单据的数据） |
| loadGroupCo | `boolean`  | 是否读取集团数据                      |
| loadAll     | `boolean`  | 是否读取没有结余的单据                   |



### **例子**

当读取 应收订金单据 时，需要增加[委外代销订单]的订金，如下扩展：

```java
@Override
public void appendArOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 			tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
	String sql = "CALL l_consigncoamt2 (" + beId + ", " + uId + ", " + AIId + ", '" + tranType + 	 "', " + tranId + ", '" + tDate + "','" + orderList + "'," + (loadGroupCo ? 1 : 0) + "," + 		(loadAll ? 1 : 0) + ")";

	SqlTable myTable = CawDs.getResult(sql);
	if (myTable != null && myTable.size() > 0) {
		SqlTableLib.append(retTable, myTable);
	}
}
```



------



### `appendApOsDeposit`函数

```java
public default void appendApOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 	tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
}
```

**说明**

用于读取扩展的 应付订金单据 的数据，例如[委外加工订单]里的订金。

**参数**

| 名称          | 类型         | 说明                            |
| ----------- | ---------- | ----------------------------- |
| retTable    | `SqlTable` | 订金数据                          |
| beId        | `long`     | 企业法人ID                        |
| uId         | `long`     | 当前登录的用户ID                     |
| AIId        | `long`     | 应付对象ID                        |
| tranType    | `String`   | 读取数据的单据类型                     |
| tranId      | `long`     | 读取数据的单据ID                     |
| tDate       | `String`   | 读取数据的截至日期                     |
| orderList   | `String`   | 读取数据的单据筛选条件（若为空，则代表读取所有单据的数据） |
| loadGroupCo | `boolean`  | 是否读取集团数据                      |
| loadAll     | `boolean`  | 是否读取没有结余的订单                   |



### **例子**

当读取 应付订金单据 时，需要增加[委外加工订单]的订金，如下扩展：

```java
@Override
public void appendApOsDeposit(SqlTable retTable, long beId, long uId, long AIId, String 			tranType, long tranId, String tDate, String orderList, boolean loadGroupCo, boolean loadAll) {
	String sql = "CALL l_pdcoreac_amt (" + beId + ", " + uId + ", " + AIId + ", '" + tranType + 	"', " + tranId + ", '" + tDate + "','" + orderList + "'," + (loadGroupCo ? 1 : 0) + "," + 		(loadAll ? 1 : 0) + ")";

	SqlTable myTable = CawDs.getResult(sql);
	if (myTable != null && myTable.size() > 0) {
		SqlTableLib.append(retTable, myTable);
	}
}
```



## FinanceDataHelper

### 目的

用于扩展应收发票。

<br/>

### `updateArInvoiceRemain`函数

```java
public default void updateArInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
}
```

**说明**

用于读取扩展的 应收发票 的结余金额，例如[XXXX应收发票]。

**参数**

| 名称         | 类型         | 说明        |
| ---------- | ---------- | --------- |
| retTable   | `SqlTable` | 发票结余金额的数据 |
| beId       | `long`     | 企业法人ID    |
| uId        | `long`     | 当前登录的用户ID |
| AIType     | `String`   | 应收对象类别    |
| AIId       | `long`     | 应收对象ID    |
| moduleFrom | `String`   | 读取数据的单据类型 |
| sourceId   | `long`     | 读取数据的单据ID |
| sTranId    | `long`     | 应收发票的单据ID |
| multiId    | `long`     | 批量收款单ID   |
| sTranType  | `String`   | 应收发票的单据类型 |
| tDate      | `String`   | 读取数据的截至日期 |



### **例子**

当读取[XXXX应收发票]的应收结余金额时，如下扩展：

```java
@Override
public default void updateArInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
		String sql = "CALL l_xxxx_arRemain (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", '" + moduleFrom + "', " + sourceId + ", '" + sTranType + "', " + sTranId + "," 		+ multiRecId + ",'" + tDate + "')";	

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### `updateApInvoiceRemain`函数

```java
public default void updateApInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
}
```

**说明**

用于读取扩展的 应付发票 的结余金额，例如[XXXX应付发票]。

**参数**

| 名称         | 类型         | 说明        |
| ---------- | ---------- | --------- |
| retTable   | `SqlTable` | 发票结余金额的数据 |
| beId       | `long`     | 企业法人ID    |
| uId        | `long`     | 当前登录的用户ID |
| AIType     | `String`   | 应付对象类别    |
| AIId       | `long`     | 应付对象ID    |
| moduleFrom | `String`   | 读取数据的单据类型 |
| sourceId   | `long`     | 读取数据的单据ID |
| sTranId    | `long`     | 应付发票的单据ID |
| multiId    | `long`     | 批量付款单ID   |
| sTranType  | `String`   | 应付发票的单据类型 |
| tDate      | `String`   | 读取数据的截至日期 |



### **例子**

当读取[XXXX应付发票]的应付结余金额时，如下扩展：

```java
@Override
public default void updateApInvoiceRemain(SqlTable retTable, long beId, long uId, String AIType, 	long AIId, String moduleFrom, long sourceId, long sTranId, long multiId, String sTranType, 		String tDate) {
		String sql = "CALL l_xxxx_apRemain (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", '" + moduleFrom + "', " + sourceId + ", '" + sTranType + "', " + sTranId + "," 		+ multiRecId + ",'" + tDate + "')";	

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### `appendArOsInvoice`函数

```java
public default void appendArOsInvoice(SqlTable retTable, long beId, long uId, String AIType, 		long AIId, long recregId, long multiRecId, String sDate, String eDate, String sDDate, String 	 eDDate, String sStaff, String eStaff, int loadCrNote, String invList, String sTranType, 		String moduleFrom, boolean loadGroupCo) {
}
```

**说明**

用于读取扩展的 应收发票 的结余数据，例如[XXXX应收发票]。

**参数**

| 名称          | 类型         | 说明                          |
| ----------- | ---------- | --------------------------- |
| retTable    | `SqlTable` | 发票结余数据                      |
| beId        | `long`     | 企业法人ID                      |
| uId         | `long`     | 当前登录的用户ID                   |
| AIType      | `String`   | 应收对象类别                      |
| AIId        | `long`     | 应收对象ID                      |
| recregId    | `long`     | 读取发票的单据ID                   |
| multiRecId  | `long`     | 批量收款单ID                     |
| sDate       | `String`   | 读取数据的开始日期                   |
| eDate       | `String`   | 读取数据的截至日期                   |
| sDDate      | `String`   | 读取数据的开始到期日                  |
| eDDate      | `String`   | 读取数据的截至到期日                  |
| sStaff      | `String`   | 读取数据的开始职员编号                 |
| eStaff      | `String`   | 读取数据的截至职员编号                 |
| loadCrNote  | `int`      | 读取没有结余的单据（1：是；0：否）          |
| invList     | `String`   | 应收发票的筛选条件（若为空，则代表读取所有单据的数据） |
| sTranType   | `String`   | 应收发票类型筛选条件                  |
| moduleFrom  | `String`   | 读取发票的单据类型                   |
| loadGroupCo | `boolean`  | 读取集团数据                      |



### **例子**

当读取[XXXX应收发票]的应收结余数据时，如下扩展：

```java
@Override
public void appendArOsInvoice(SqlTable retTable, long beId, long uId, String AIType, long AIId, 	long recregId, long multiRecId, String sDate, String eDate, String sDDate, String eDDate, 		String sStaff, String eStaff, int loadCrNote, String invList, String sTranType, String 			moduleFrom, boolean loadGroupCo) {
		String sql = "CALL l_xxxx_napbal (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", " + payRegId + ", " + multiPayId + ", '" + sDate + "','" + eDate + "','" + 			sDDate + "','" + eDDate + "','" + sStaff + "','" + eStaff + "'," + loadDbNote + ", '" + 		invList + "','" + sTranType + "', '" + moduleFrom + "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```



------



### `appendApOsInvoice`函数

```java
public default void appendApOsInvoice(SqlTable retTable, long beId, long uId, String AIType, 		long AIId, long payRegId, long multiPayId, String sDate, String eDate, String sDDate, String 	eDDate, String sStaff, String eStaff, int loadDbNote, String invList, String sTranType, 		String moduleFrom, boolean loadGroupCo) {
}
```

**说明**

用于读取扩展的 应付发票 的结余数据，例如[XXXX应付发票]。

**参数**

| 名称          | 类型         | 说明                          |
| ----------- | ---------- | --------------------------- |
| retTable    | `SqlTable` | 发票结余数据                      |
| beId        | `long`     | 企业法人ID                      |
| uId         | `long`     | 当前登录的用户ID                   |
| AIType      | `String`   | 应付对象类别                      |
| AIId        | `long`     | 应付对象ID                      |
| payRegId    | `long`     | 读取发票的单据ID                   |
| multiPayId  | `long`     | 批量付款单ID                     |
| sDate       | `String`   | 读取数据的开始日期                   |
| eDate       | `String`   | 读取数据的截至日期                   |
| sDDate      | `String`   | 读取数据的开始到期日                  |
| eDDate      | `String`   | 读取数据的截至到期日                  |
| sStaff      | `String`   | 读取数据的开始职员编号                 |
| eStaff      | `String`   | 读取数据的截至职员编号                 |
| loadDbNote  | `int`      | 读取没有结余的单据（1：是；0：否）          |
| invList     | `String`   | 应付发票的筛选条件（若为空，则代表读取所有单据的数据） |
| sTranType   | `String`   | 应付发票类型筛选条件                  |
| moduleFrom  | `String`   | 读取发票的单据类型                   |
| loadGroupCo | `boolean`  | 读取集团数据                      |



### **例子**

当读取[XXXX应付发票]的应付结余数据时，如下扩展：

```java
@Override
public void appendApOsInvoice(SqlTable retTable, long beId, long uId, String AIType, long AIId, 	long payRegId, long multiPayId, String sDate, String eDate, String sDDate, String eDDate, 		String sStaff, String eStaff, int loadDbNote, String invList, String sTranType, String 			moduleFrom, boolean loadGroupCo) {
		String sql = "CALL l_prodac_napbal (" + beId + ", " + uId + ", '" + AIType + "', " + 			AIId + ", " + payRegId + ", " + multiPayId + ", '" + sDate + "','" + eDate + "','" + 			sDDate + "','" + eDDate + "','" + sStaff + "','" + eStaff + "'," + loadDbNote + ", '" + 		invList + "','" + sTranType + "', '" + moduleFrom + "', " + (loadGroupCo ? 1 : 0) + ")";

		SqlTable myTable = CawDs.getResult(sql);
		if (myTable != null && myTable.size() > 0) {
			SqlTableLib.append(retTable, myTable);
		}
}
```

